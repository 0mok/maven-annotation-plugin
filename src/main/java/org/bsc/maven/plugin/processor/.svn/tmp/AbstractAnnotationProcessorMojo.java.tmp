package org.bsc.maven.plugin.processor;

import java.io.File;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

import javax.tools.JavaCompiler;
import javax.tools.JavaFileObject;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;
import javax.tools.JavaCompiler.CompilationTask;

import org.apache.maven.artifact.DependencyResolutionRequiredException;
import org.apache.maven.model.Resource;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.project.MavenProject;
import org.codehaus.plexus.util.FileUtils;
import org.codehaus.plexus.util.StringUtils;
import org.jfrog.maven.annomojo.annotations.MojoParameter;

public abstract class AbstractAnnotationProcessorMojo extends AbstractMojo
{

    @MojoParameter(expression = "${project}", readonly = true, required = true)
    protected MavenProject project;

    @MojoParameter(required = false, defaultValue="${project.build.outputDirectory}")
    private File outputDirectory;

    @MojoParameter(required = false, description = "Annotation Processor FQN (Full Qualified Name) - when processors are not specified, the default discovery mechanism will be used")
    private String[] processors;

    @MojoParameter(required = false, description = "Additional compiler arguments")
    private String compilerArguments;

    @MojoParameter(required = false, description = "Controls whether or not the output directory is added to compilation")
    private Boolean addOutputDirectoryToCompilationSources;

    protected abstract File getSourceDirectory();

    private String buildProcessor()
    {
        if (processors == null || processors.length == 0)
        {
            return null;
        }

        StringBuilder result = new StringBuilder();

        int i = 0;

        for (i = 0; i < processors.length - 1; ++i)
        {
            result.append(processors[i]).append(',');
        }

        result.append(processors[i]);

        return result.toString();
    }

<<<<<<< .mine
    protected abstract List<Resource> getResourceForClasspath();

=======
    protected abstract List getClasspathElements();

>>>>>>> .r130
    @SuppressWarnings("unchecked")
    private String buildCompileClasspath(  )
    {
<<<<<<< .mine

        List<String> pathElements = null;
        try
        {
            pathElements = project.getCompileClasspathElements();
        }
        catch (DependencyResolutionRequiredException e)
        {

            super.getLog().warn("exception calling getCompileClasspathElements", e);

            return null;
        }

        if (pathElements.isEmpty())
        {
            return null;
        }

=======
        List<String> pathElements = getClasspathElements();
       
>>>>>>> .r130
        StringBuilder result = new StringBuilder();

        int i = 0;

        List<Resource> resourceList = getResourceForClasspath();

        if( resourceList!=null ) {
            for( Resource r : resourceList  ) {
                result.append(r.getDirectory()).append(File.pathSeparator);
            }
        }

        for (i = 0; i < pathElements.size() - 1; ++i)
        {
            result.append(pathElements.get(i)).append(File.pathSeparator);
        }

        result.append(pathElements.get(i));

        return result.toString();
    }


    /**
     * 
     */
    public void execute() throws MojoExecutionException
    {
        try
        {
            executeWithExceptionsHandled();
        }
        catch (Exception e1)
        {
            super.getLog().error("execute error", e1);
            throw new MojoExecutionException(e1.getMessage());
        }

    }

    private void executeWithExceptionsHandled() throws Exception
    {
        if (outputDirectory == null)
        {
            outputDirectory = getDefaultOutputDirectory();
        }

        ensureOutputDirectoryExists();
        addOutputToSourcesIfNeeded();

        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);

        // new Debug(project).printDebugInfo();

        List<File> files = FileUtils.getFiles(getSourceDirectory(), "**/*.java", null);

        Iterable< ? extends JavaFileObject> compilationUnits1 = fileManager
                .getJavaFileObjectsFromFiles(files);


        String compileClassPath = buildCompileClasspath();

        String processor = buildProcessor();

        List<String> options = new ArrayList<String>(10);

        options.add("-cp");
        options.add(compileClassPath);
        options.add("-proc:only");

        addCompilerArguments(options);

        if (processor != null)
        {
            options.add("-processor");
            options.add(processor);
        }
        else
        {
            getLog().info("No processors specified. Using default discovery mechanism.");
        }

        options.add("-s");
        options.add(outputDirectory.getPath());


        for (String option : options)
        {
            getLog().info("javac option: " + option);
        }


        CompilationTask task = compiler.getTask(new PrintWriter(System.out), fileManager, null,
                options, null, compilationUnits1);

        /*
         * //Create a list to hold annotation processors LinkedList<Processor> processors = new
         * LinkedList<Processor>();
         * 
         * //Add an annotation processor to the list processors.add(p);
         * 
         * //Set the annotation processor to the compiler task task.setProcessors(processors);
         */

        // Perform the compilation task.
        task.call();
    }

    private void addCompilerArguments(List<String> options)
    {
        if (!StringUtils.isEmpty(compilerArguments))
        {
            for (String arg : compilerArguments.split(" "))
            {
                if (!StringUtils.isEmpty(arg))
                {
                    arg = arg.trim();
                    getLog().info("Adding compiler arg: " + arg);
                    options.add(arg);
                }
            }
        }
    }

    private void addOutputToSourcesIfNeeded()
    {
        final Boolean add = addOutputDirectoryToCompilationSources;
        if (add == null || add.booleanValue())
        {
            getLog().info("Source directory: " + outputDirectory + " added");
            addCompileSourceRoot(project, outputDirectory.getAbsolutePath());
        }
    }

    protected abstract void addCompileSourceRoot(MavenProject project, String dir);

    private void ensureOutputDirectoryExists()
    {
        final File f = outputDirectory;
        if (!f.exists())
        {
            f.mkdirs();
        }
    }


    public abstract File getDefaultOutputDirectory();

}
